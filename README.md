# Cryptography task 5
Сделать программу - консольное приложение, используя языки: С/C++, Rust, Python, Go, Node.JS. Код должен быть оформлен в  отдельный репозитарий на GitHub c инструкцией в README.md как собрать и запустить код в консоли под Ubuntu 18.04. К заданию должен быть приложен скриншот или текст вывода одного или нескольких прогонов программы(!).
Программа эмулирует работу автомобильного брелока, открывающего машину, с использованием ЭЦП в условиях, когда канал связи полностью доступен любому прослушивающему (в том числе и в течение большого времени и попыток), также атакующий может повторить прослушанные данные.
То, что передается в реальном протоколе по сети в программе просто записывается в переменную и передается функции следующего шага в виде параметров, типа:

```js
let handhsake_data = trinket_generate_hasndshake(...);
printf(“...trinket->car send data: ....”, handhsake_data);

let challenge_data = car_process_handshake(handshake_data);
printf(“... car->trinket send data: ...”, challenge_data);

let response_data = trinket_process_challenge(challenge_data);
printf(“...trinket->car send data: ....”, response_data);
```

Возможны различные варианты построения протокола, вот один из них:
Handshake. На этом этапе брелок отправляет машине код команды (любые данные, в истинности которых машина должна удостовериться)
Challenge. Машина отправляет брелоку данные, с которыми брелок должен что-то сделать, что докажет машине, что это именно ее брелок
Response. Брелок делает то, что нужно, отправляя машние доказательство того, что это именно он отправил Handshake
Машина проверяет доказательство и исполняет команду

Программа последовательно демонстрирует этапы протокола, печатая в консоль кто кому и какие данные отправляет. Код желательно оформить так, чтобы можно было удобно идентифицировать каждый шаг протокола и связать его с выводом в консоль. В протоколе необходимо использовать один из алгоритмов генерации и проверки ЭЦП (любой алгоритм). Некоторые данные могут храниться одновременно и в брелоке и в машине (прописываться когда ключ “привязывается” к машине).


Пример вывода программы:
```
0: (registration) 0xXXXXXXXXXXXX (pubkey1 written to trinked), 0xXXXXXXXXXXXXXX (pubkey2 written to car)
1: (handshake) trinket -> car, 0xXXXXXX (id command), 0xXXXXXXX (challenge for car)
2: (challenge) car -> trinket: 0xXXXXXX(challenge for trinket), 0xXXXXXXX (confirm challenge for car)
3: (response) trinket->car: 0xXXXXXXX (confirm challenge for trinket)
4: (action) car: check response - ok, OPEN DOOR
```
Логика, последовательность шагов, внутренние данные - все это вы проектируете сами, единственное требование - генерация и проверка ЭЦП. Рекомендуется сначала спроектировать протокол с пустыми mock-нутыми функциями generate_sig() и verify_sig() и лишь в конце использовать криптографичекую билиотеку.

Examples of jobs you can see in "screens" folder
To run the program:

cd ./asymmetry

go mod tidy 

go run .


